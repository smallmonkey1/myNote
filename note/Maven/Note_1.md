## Maven的核心概念

约定的目录结构(重点)

POM(重点)

坐标(重点)

依赖(重中之重)

仓库

生命周期/插件/目标

继承

聚合

---

## 目录：

根目录：工程名

src目录：源码

pom.xml文件：Maven工程的核心配置文件

main目录：存放主程序

test目录：存放测试程序

java目录：存放java源文件

resources目录：存放框架或其他工具的配置文件

### 为什么要遵守约定的目录结构？

Maven好找

---

### 常用的Maven命令

注意：执行与构建过程相关的Maven命令，必须进入pom.xml所在的目录-->编译、测试、打包….

mvn clean：清理

mvn compile：编译主程序

mvn test-compile：编译测试程序

mvn test：执行测试

mvn package：打包

mvn install：安装

mvn site：生成站点

### 联网问题

maven的核心程序中紧紧定义了抽象的生命周期，但是具体的工作必须由特定的插件来完成。而插件本身并不包含在Maven的核心程序中

当我们执行的Maven命令需要用到某些插件时，maven核心程序会先到本地仓库中查找。

本地仓库默认位置：系统中当前目录的家目录--./m2/repository

Maven核心程序如果在本地仓库找不到，就会自动联网下载

如果无法联网，构建失败

修改人本地仓库的位置可以让Maven核心程序到自定义本地仓库找插件

​	在Maven目录下\conf\settings.xml

​	修改localRepository标签

---

### POM

含义：Project Object Model-项目对象模型





---

### 坐标

使用下面3个向量在仓库中唯一定位一个Maven工程

groupid：公司或组织域名倒叙+项目名

artifactid：模块名

version：版本

00000000000000

坐标与仓库中的路径一一对应

---

### 仓库

本地仓库：当前电脑上的仓库目录

远程仓库：

* 局域网(私服)：为局域网服务
* 中央仓库：为所有用户服务
* 中央仓库镜像：复制中央仓库，加快下载速度

---

### 依赖

Maven解析依赖信息时会到本地仓库查找被依赖的包

对于们自己开发的Maven宫女晨，用**install命令**安装后就可以进入仓库

##### 依赖范围：

**compile：test：provided**：

|                    | compile | **test：** | provided |
| ------------------ | ------- | ---------- | -------- |
| 对主程序是否有效   | Y       | N          | Y        |
| 对测试程序是否有效 | Y       | Y          | N        |
| 是否参与打包       | Y       | N          | N        |

---

### 生命周期

各个构建环节执行的顺序：不能打乱顺序，必须按照既定的正确顺序来执行

Maven的核心程序中定义了抽象的生命周期。生命周期中各个阶段的具体任务是由插件来完成

Maven核心程序为了更好的实现自动化构建，按照这一特点执行生命周期中的各个阶段：不论现在执行生命周期中的哪一阶段，都是从这个生命周期最初的位置开始执行的。

通俗的说：直接运行打包，Maven就会自动将前面的步骤帮我做完，如果想要前面的单独功能(测试、编译….)就另说

---

### 插件和目标

生命周期的各个阶段仅仅定义了要执行的任务是什么

各个阶段和插件的目标是对应的

相似的目标由特定的插件来完成

| 生命周期阶段 | 插件目标    | 插件                  |
| ------------ | ----------- | --------------------- |
| compile      | compile     | maven-compiler-plugin |
| test-compile | testCompile | maven-compiler-plugin |
|              |             |                       |

可以将目标看做 “调用插件功能的命令”

---

### 依赖传递

只有compile范围能传递

### 依赖排除

需要设置排除的场合

在`<dependency>`里面加上`<exclusions>`

### 依赖原则

作用：解决模块工程之间的jar包冲突问题

情景1：

* 路径最短优先，要离本项目最近的

![image-20200310235023204](E:\Desktop\note\Maven\image-20200310235023204.png)

情景2：

* 路径相同时，先声明者优先
* 指的是`<dependency>`顺序

![image-20200310235057227](E:\Desktop\note\Maven\image-20200310235057227.png)

---

### 同一管理依赖的版本

情景举例：

* 对spring的jar包同一升级或者降级，手动修改不可靠

##### 建议的配置方式：

使用`<properties>`标签内使用自定义标签同一声明版本号

```xml
<properties>
<sprint.version>4.0.0.RELEASE</sprint.version>//自定义的标签
</properties>
```



在需要同一版本的位置，使用`${自定义标签名}`引用声明的版本号

```xml
<dependency>
	..
    ..
    <version>${sprint.version}</version>
</dependency>
```

`<properties>`标签配合自定义标签声明数据的配置并不是只能声明版本号，还可以做其他的自定义配置

方式需要同一声明后的场合都可以使用

---

### 继承

依赖继承

由于test范围的依赖不能传递，所以必然分散在各个模块工程，容易造成版本不一致

需求：同一管理各个模块工程中对junit依赖的版本

解决思路：将junit依赖版本同一提取到“父”工程中，在子工程中声明junit依赖时不指定版本。以父工程同一设定为准。同时也便于修改

##### 操作：

创建一个Maven工程作为父工程，注意：打包方式为pom

在子工程中声明对父工程的应用

将子工程的坐标中与父工程坐标中重复的内容删除

在父工程中统一**管理**junit的依赖

```xml
<dependencyManagement>
	junit的依赖
</dependencyManagement>
```



在子工程中删除junit依赖的版本号部分

---

### 聚合

作用：一键安装各个模块工程

配置方式：在一个**总的聚合工程中**配置各个参与聚合的模块

```xml
<modules>
	<modele>../模块1</modele>
    <modele>../模块2</modele>
    <modele>../模块3</modele>
</modules>
```

使用是：在聚合工程的pom.xml上右键-->run as –>maven install

---

### 自动部署

算了  百度吧 

