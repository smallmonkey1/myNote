### 是什么

可以一次执行多个命令，本质是一组命令的集合。

一个事务中的所有命令都会序列化，**按顺序地串行化执行，而不会被其他命令插入，不许加塞**

---

### 能干嘛

一个队列中，一次性、顺序性、排他性的执行一系列命令

---

### 怎么用

#### 常用命令

discard：取消事务

exec：执行事务

multi：标记一个事务的开始

unwatch：取消watch对所有key的监视

watch key[key…]：监视一个或多个key，如果在事务执行之前这个key被其他命令改动，那么事务将被打断。

---

#### 正常执行&放弃事务



```shell
#示例
multi
set k1 v1
set k2 v2
get k2
set k3 v3
exec/discard(执行/取消)
```

---

#### 全体连坐

* 当事务块中有一处出问题，整个事务都不会执行
* 有命令错，有命令不能插入queue，后面的都不执行
* 类似于：编译时报错就不执行

#### 冤头债主

* 只要不报错，命令被插入queue中，其他的都能执行
* 运行时异常不会牵连整个事务

#### watch监控(重点)

* 单独开个文件来说
* 保证事务的原子性

#### 小结：

watch指令 类似乐观锁 事务提交时 如果key的值被其他客户端改变 整个事务队列不会被执行

通过watch命令在事务执行之前监控多个keys，若在watch之后又任何key的值发生变化 exec命令执行的事务都将被放弃 同时返回Nullmulti-bulk应答以通知调用者事务执行失败

---

### 3阶段

开启：以MULTI开始一个事务

入队：将多个命令入队到事务中 等待执行，像批处理

执行：exec

---

###3特性

单独的隔离操作：事务中所有命令都会序列化，执行过程中不会被其他客户端发送的命令请求打断

没有隔离级别的概念：队列中的命令没有提交之前不会实际的被执行，因为事务提交前任何指令不会被执行，也就不存在“事务年内的查询要看到事务里的更新，在事务外查询不能看到”这个令人十分头痛的问题

不真原子性：redis同一个事务中如果有一条命令执行失败，气候的命令仍然会被执行，没有回滚